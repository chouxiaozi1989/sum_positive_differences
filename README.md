# 数组正差值累加和算法实现

## 问题描述

给定随机整数数组a，长度400000，元素最大值100000000，对于任意i<j，求当a[j]-a[i]>0时所有a[j]-a[i]的累加和。

## 解决方案

### 算法思路

1. **朴素算法 (O(n²))**：双重循环直接计算所有满足条件的差值
2. **优化算法 (O(n log n))**：使用树状数组和坐标压缩技术

### 核心优化思想

对于每个位置j的元素arr[j]，计算：
- 在位置j之前有多少个元素小于arr[j]
- 这些小于arr[j]的元素的总和
- arr[j]对答案的贡献 = arr[j] × count - sum

### 技术要点

- **坐标压缩**：将数组值映射到较小的范围内
- **树状数组**：支持O(log n)的单点更新和前缀查询
- **空间复杂度**：O(n)

## 文件说明

- `sum_positive_differences.py` - 基础实现和测试
- `optimized_sum_algorithm.py` - 优化算法实现
- `complete_solution.py` - 完整解决方案（推荐使用）

## 运行结果

### 性能对比

| 数组大小 | 朴素算法耗时 | 优化算法耗时 | 加速比 |
|---------|-------------|-------------|--------|
| 1,000   | 0.0552s     | 0.0040s     | 13.87x |
| 5,000   | 1.0999s     | 0.0162s     | 67.97x |
| 10,000  | 4.4090s     | 0.0419s     | 105.25x|
| 20,000  | 16.4345s    | 0.0902s     | 182.18x|

### 最终结果

**400,000长度数组的正差值累加和：1,333,668,082,603,911,821**

- 计算耗时：2.87秒
- 算法复杂度：O(n log n)
- 内存使用：约400MB

## 使用方法

```bash
python complete_solution.py
```

## 算法验证

所有测试用例均通过验证，包括：
- 基础功能测试
- 边界条件测试
- 性能压力测试
- 结果一致性验证